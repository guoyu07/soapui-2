{
  HttpConnection connection=null;
  int maxHostConnections=this.params.getMaxConnectionsPerHost(hostConfiguration);
  int maxTotalConnections=this.params.getMaxTotalConnections();
synchronized (connectionPool) {
    hostConfiguration=new SoapUIHostConfiguration(hostConfiguration);
    HostConnectionPool hostPool=connectionPool.getHostPool(hostConfiguration,true);
    WaitingThread waitingThread=null;
    boolean useTimeout=(timeout > 0);
    long timeToWait=timeout;
    long startWait=0;
    long endWait=0;
    while (connection == null) {
      if (shutdown) {
        throw new IllegalStateException("Connection factory has been shutdown.");
      }
      if (hostPool.freeConnections.size() > 0) {
        connection=connectionPool.getFreeConnection(hostConfiguration);
      }
 else       if ((hostPool.numConnections < maxHostConnections) && (connectionPool.numConnections < maxTotalConnections)) {
        connection=connectionPool.createConnection(hostConfiguration);
      }
 else       if ((hostPool.numConnections < maxHostConnections) && (connectionPool.freeConnections.size() > 0)) {
        connectionPool.deleteLeastUsedConnection();
        connection=connectionPool.createConnection(hostConfiguration);
      }
 else {
        try {
          if (useTimeout && timeToWait <= 0) {
            throw new ConnectionPoolTimeoutException("Timeout waiting for connection");
          }
          if (LOG.isDebugEnabled()) {
            LOG.debug("Unable to get a connection, waiting..., hostConfig=" + hostConfiguration);
          }
          if (waitingThread == null) {
            waitingThread=new WaitingThread();
            waitingThread.hostConnectionPool=hostPool;
            waitingThread.thread=Thread.currentThread();
          }
 else {
            waitingThread.interruptedByConnectionPool=false;
          }
          if (useTimeout) {
            startWait=System.currentTimeMillis();
          }
          hostPool.waitingThreads.addLast(waitingThread);
          connectionPool.waitingThreads.addLast(waitingThread);
          connectionPool.wait(timeToWait);
        }
 catch (        InterruptedException e) {
          if (!waitingThread.interruptedByConnectionPool) {
            LOG.debug("Interrupted while waiting for connection",e);
            throw new IllegalThreadStateException("Interrupted while waiting in MultiThreadedHttpConnectionManager");
          }
        }
 finally {
          if (!waitingThread.interruptedByConnectionPool) {
            hostPool.waitingThreads.remove(waitingThread);
            connectionPool.waitingThreads.remove(waitingThread);
          }
          if (useTimeout) {
            endWait=System.currentTimeMillis();
            timeToWait-=(endWait - startWait);
          }
        }
      }
    }
  }
  return connection;
}
